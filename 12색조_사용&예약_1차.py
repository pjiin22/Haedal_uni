# -*- coding: utf-8 -*-
"""12색조_사용&예약 1차

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1r6TNPmGU92NsZGdjaP3Po1KPSTPnNMmJ

- 라이브러리 설치
"""

!pip install fastapi uvicorn nest-asyncio pyngrok

!apt install tesseract-ocr

!pip install pytesseract pillow fastapi uvicorn nest-asyncio pyngrok

!pip install python-jose[cryptography]

!pip install python-multipart

!pip install python-dotenv

from fastapi import FastAPI
from fastapi import HTTPException, Depends, Header
from fastapi.openapi.utils import get_openapi
from fastapi.openapi.models import APIKey, APIKeyIn, SecuritySchemeType
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi import UploadFile, File
from fastapi.responses import JSONResponse
from fastapi import Depends

from jose import JWTError
from jose import  jwt

from dotenv import load_dotenv

import os

from pydantic import BaseModel

from datetime import datetime, timedelta
security = HTTPBearer()

import sqlite3

import shutil

import os
from fastapi import FastAPI, UploadFile, File #사진

from PIL import Image
import pytesseract

from io import BytesIO

from typing import Optional

from PIL import Image

import pytesseract

from io import BytesIO
import sqlite3

app = FastAPI()

"""# JMT 함수"""

with open(".env", "w") as f:
    f.write("SECRET_KEY=my-super-secret-key")

#임의로 ㄱ

load_dotenv()

SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = "HS256"

print(SECRET_KEY)

def decode_token(token: str):
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        return payload.get("sub")
    except JWTError:
        raise HTTPException(status_code=401, detail="토큰이 유효하지 않습니다.")

"""# 보안"""

from fastapi.openapi.utils import get_openapi

def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema

    openapi_schema = get_openapi(
        title="빈강의실 관리 시스템",
        version="1.0.0",
        description="JWT 인증 포함 Swagger 문서",
        routes=app.routes,
    )
    openapi_schema["components"]["securitySchemes"] = {
        "BearerAuth": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT"
        }
    }
    for path in openapi_schema["paths"].values():
        for operation in path.values():
            operation["security"] = [{"BearerAuth": []}]
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi

"""# 사용자 토큰"""

def create_token(user_id: str):
    payload = {
        "sub": user_id,
        "exp": datetime.utcnow() + timedelta(hours=1)
    }
    return jwt.encode(payload, SECRET_KEY, algorithm=ALGORITHM)

print(create_token("user1"))

@app.post("/reserve/{id}/use-file")
def use_reservation_file(
    id: int,
    file: UploadFile = File(...),
    authorization: str = Header(...)
):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = user_reservations.get(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="접근 권한 없음")

"""# 예약 현황

### 예약 목록
"""

class ReservationResponse(BaseModel):
    room_id: int
    time: str
    status: str

@app.get("/my-reservations", response_model=list[ReservationResponse])
def get_my_reservations():
    return [
        {"room_id": 301, "time": "10:00", "status": "reserved"},
        {"room_id": 302, "time": "13:00", "status": "in_use"}
    ]

"""### 사용 중 인증"""

class PhotoAuth(BaseModel):
    photo_url: str

@app.post("/reserve/{id}/use-url")
def use_reservation_url(id: int, data: PhotoAuth):
    return {"message": f"예약 {id}번 사용 인증 완료", "photo": data.photo_url}

{
  "photo_url": "https://image.com/photo.png"
}

"""### 예약 취소"""

@app.delete("/reserve/{id}")
def cancel_reservation(id: int):
    return {"message": f"예약 {id}번 취소 완료"}

"""# 사용 현황

### 내 등급
"""

@app.get("/my-grade")
def get_grade(user_id: str = "user1"):
    return {"user_id": user_id, "grade": 87}

"""### 남은 시간"""

@app.get("/my-usage-time")
def get_usage_time(authorization: str = Header(...)):
    try:
        token = authorization.split(" ")[1]
        user_id = decode_token(token)

        conn = sqlite3.connect("reservations.db")
        cursor = conn.cursor()
        cursor.execute("""
            SELECT start_time, end_time
            FROM reservations
            WHERE user_id = ?
            ORDER BY id DESC
            LIMIT 1
        """, (user_id,))
        row = cursor.fetchone()
        conn.close()

        if not row or not row[0] or not row[1]:
            raise HTTPException(
                status_code=500,
                detail=f"예약 정보가 유효하지 않음. row: {row}"
            )


        start_time = datetime.fromisoformat(row[0])
        end_time = datetime.fromisoformat(row[1])
        now = datetime.now()

        minutes_left = max(int((end_time - now).total_seconds() // 60), 0)

        return {
            "start_time": start_time.isoformat(),
            "end_time": end_time.isoformat(),
            "minutes_left": minutes_left
        }

    except Exception as e:
        raise HTTPException(status_code=500, detail=f"서버 오류: {str(e)}")

"""# 사진업로드"""

@app.post("/reserve/{id}/use")
def use_reservation(id: int, authorization: str = Header(...)):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = user_reservations.get(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="예약 정보 없음 또는 권한 없음")

    reservation["status"] = "in_use"

    return {
        "message": "사용 상태로 전환됨",
        "room_id": reservation["room_id"]
    }

"""# 사용시간 API"""

def get_active_reservation(user_id: str):
    conn = sqlite3.connect("reservations.db")
    cursor = conn.cursor()
    cursor.execute("""
        SELECT start_time, end_time
        FROM reservations
        WHERE user_id = ? AND status = 'in_use'
    """, (user_id,))
    row = cursor.fetchone()
    conn.close()
    return row

@app.get("/my-usage-time")
def get_usage_time(authorization: str = Header(...)):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    row = get_active_reservation(user_id)
    if not row:
        raise HTTPException(status_code=404, detail="사용 중인 예약이 없습니다.")

    start_time_str, end_time_str = row
    start_time = datetime.fromisoformat(start_time_str)
    end_time = datetime.fromisoformat(end_time_str)
    now = datetime.now()

    minutes_left = max(int((end_time - now).total_seconds() // 60), 0)

    return {
        "start_time": start_time.isoformat(),
        "end_time": end_time.isoformat(),
        "minutes_left": minutes_left
    }

"""# 퇴실 처리"""

@app.post("/reserve/{id}/exit")
def exit_reservation(id: int, authorization: str = Header(...)):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = user_reservations.get(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="예약 정보 없음 또는 권한 없음")

    now = datetime.now()
    end_time = datetime.fromisoformat(reservation["end_time"])
    used_minutes = int((now - datetime.fromisoformat(reservation["start_time"])).total_seconds() // 60)

    reservation["status"] = "exited"

    return {
        "message": "퇴실 완료",
        "used_minutes": used_minutes,
        "room_id": reservation["room_id"]
    }

"""# 등급API

# 예약API

프론트 후 하기
"""



"""# SQLite

### DB생성
"""

import sqlite3

conn = sqlite3.connect("reservations.db")
cursor = conn.cursor()

cursor.execute("""
CREATE TABLE IF NOT EXISTS reservations (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    user_id TEXT,
    room_id INTEGER,
    status TEXT,
    start_time TEXT,
    end_time TEXT
)
""")

cursor.execute("""
INSERT INTO reservations (user_id, room_id, status, start_time, end_time)
VALUES ("user1", 302, "reserved", "2025-05-25T13:00", "2025-05-25T14:00")
""")

conn.commit()
conn.close()

"""### DB조회"""

def get_reservation_from_db(reserve_id: int):
    conn = sqlite3.connect("reservations.db")
    cursor = conn.cursor()
    cursor.execute("SELECT user_id, room_id FROM reservations WHERE id = ?", (reserve_id,))
    row = cursor.fetchone()
    conn.close()

    if row:
        return {"user_id": row[0], "room_id": row[1]}
    else:
        return None

"""### 기존API생성"""

@app.post("/reserve/{id}/use")
async def use_reservation(
    id: int,
    file: UploadFile = File(...),
    authorization: str = Header(...)
):
    token = authorization.split(" ")[1]
    user_id = decode_token(token)

    reservation = get_reservation_from_db(id)
    if not reservation or reservation["user_id"] != user_id:
        raise HTTPException(status_code=403, detail="접근 권한 없음")

    image = Image.open(BytesIO(await file.read()))
    ocr_text = pytesseract.image_to_string(image)

    expected_room = str(reservation["room_id"])
    if expected_room not in ocr_text:
        raise HTTPException(status_code=400, detail="사진에서 강의실 번호를 확인할 수 없음")

    return {"message": "인증 성공", "room_number": expected_room}

"""# 테스트용 JWT 생성기"""

!ngrok config add-authtoken "2xY2WVmlvhaDE3oxlQE4PbG0bnL_42qcjEv2FGLFfMZUaLTQP"

import threading

from pyngrok import ngrok
import uvicorn

def run_app():
    uvicorn.run(app, host="0.0.0.0", port=8000)

thread = threading.Thread(target=run_app)
thread.start()

public_url = ngrok.connect(8000)
print("🔗 Swagger 주소:", public_url.public_url + "/docs")

"""# 테스트셋"""

user_reservations = {
    1: {
        "user_id": "user1",
        "room_id": 9,
        "start_time": "2025-05-25T10:00:00",
        "end_time": "2025-05-25T12:00:00",
        "status": "reserved"
    }
}

